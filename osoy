#!/bin/sh

err() { echo "error: $*" && exit; }
msg() {
  printf '\033[2m##\033[22m '
  if [ "$1" = '-n' ]
  then shift; printf "$@"
  else echo "$@"
  fi
}

# check dependencies
isInstalled() { command -v "$*" >/dev/null; }
missingdeps=
for dep in sed grep find sort cut tr curl git
do isInstalled "$dep" || missingdeps="$dep $missingdeps"
done
if [ -n "$missingdeps" ]
then err "required but not installed: $missingdeps"
fi


osoydir="$HOME/.osoy"

help() {
  echo "
  Usage: osoy <operator> [flags]

  Flags:
    -d         <domain>   enforce a specific domain to clone from         v
    -a         <author>   specify packages' author                        v
    -p         <protocol> specify a protocol other than HTTPS             v
    -b         <branch>   specify a single branch as the HEAD             v
    -B         -          clone all branches                              v
    -y         -          proceed with defaults                           v
    -f         -          force overwriting and/or removing               v
    -v         -          show version                                    v
    -h         -          show help menu                                  v

  Operator:
    c|clone    <query*>   clone packages from GitHub, GitLab or Bitbucket v
    r|remove   <query*>   remove packages                                 v
    s|symlink  [query*]   make packages' executables available in PATH    v
    u|update   [query*]   update (all) packages                           o
    l|list     [query*]   list (all) packages                             v

    dir        <query>    print package's directory path                  v
    read       <query>    view package's README file                      v
    license    <query>    view package's LICENSE file                     v
    unistall   -          uninstall osoy and all packages                 v

  Query syntax: <[[domain/]author/]package>
  "
  exit
}



# prompts
promptYes() {
  msg -n "$* [Y/n] "
  if [ -n "$y" ]
  then echo; answer=$(printf '\n')
  else read -r answer
  fi
  [ "$answer" = 'y' ] || [ "$answer" = 'Y' ] || [ "$answer" = "$(printf '\n')" ]
}
promptNo() {
  promptChoice='[y/N]'
  [ -n "$f" ] && promptChoice='[Y/n]'
  msg -n "$* $promptChoice "
  if [ -n "$y" ]
  then echo; answer=$(printf '\n')
  else read -r answer
  fi
  [ "$answer" = 'y' ] || [ "$answer" = 'Y' ] || { [ -n "$f" ] && [ "$answer" = "$(printf '\n')" ]; }
}



# array implementation
join() { tr ' ' ' '; }
split() { tr ' ' ' '; }
nth() {
  i=0
  target=$1; shift
  [ $target -lt 0 ] && target=$(($#+target))
  for val in "$@"
  do
    [ $i -eq $target ] && echo "$val" | split && break
    i=$((i+1))
  done
}
slice() {
  i=0
  start=$1; shift
  end=$1; shift
  [ $start -lt 0 ] && start=$(($#+1+start))
  [ $end -lt 0 ] && end=$(($#+1+end))
  new=
  for val in "$@"
  do
    [ $i -ge $end ] && break
    [ $i -ge $start ] && new="$new $val"
    i=$((i+1))
  done
  echo "$new"
}
count() { echo $#; }
inside() {
  key=$(echo "$1" | split); shift
  is=0
  for val in "$@"
  do [ "$(echo "$val" | split)" = "$key" ] && is=1 && break
  done
  test $is -eq 1
}




toDir() {
  cd "$osoydir" 2>/dev/null || { mkdir "$osoydir" && cd "$osoydir"; } || exit
  for subdir in "$@"
  do cd "$subdir" 2>/dev/null || { mkdir "$subdir" && cd "$subdir"; } || exit
  done
}

getFilename() { echo "$*" | sed -n 's/^.*\/\([^\/]\+\)\/\?$/\1/p'; }
getFileDirectory() { echo "$*" | sed -n 's/^\(.*\)\/[^\/]\+\/\?$/\1/p'; }
getPackageOrigin() { echo "$*" | sed -n 's/^.*\/\([^\/]\+\)\/\([^\/]\+\)\/[^\/]\+\/\?$/\1\/\2/p'; }
getPackageId() { echo "$*" | sed -n 's/^.*\/\([^\/]\+\)\/\([^\/]\+\)\/\([^\/]\+\)\/\?$/\1\/\2\/\3/p'; }

inBin() {(
  toDir "$osoydir" bin
  ls -la | sed -n 's/^l.*[0-9]\{2\}:[0-9]\{2\} \(.\+\) -> '"$(echo "$*" | sed -s 's/\//\\\//g')"'$/\1/p'
)}

linkToBin() {(
  toDir "$osoydir" bin
  filename=$(getFilename "$*")
  symbolicSource=$(ls -la | sed -n 's/^l.*[0-9]\{2\}:[0-9]\{2\} '"$filename"' -> \(.\+\)$/\1/p')
  { [ -n "$f" ] || [ -z "$symbolicSource" ]; } &&
  ln -sfv "$*" "$filename"
)}

unlinkFromBin() {(
  toDir "$osoydir" bin
  rm -vf "$(inBin "$*")" 2>/dev/null
)}

getQuery() {
  wholeQuery=
  for i in "$@"
  do
    id=$(echo "$i" | tr '/' ' ')
    package=$(nth -1 $id)
    author=$(nth -2 $id)
    domain=$(nth -3 $id)

    [ -z "$author" ] && [ -n "$a" ] && author=$a
    [ -z "$domain" ] && [ -n "$d" ] && domain=$d

    query=$(echo ".*$domain.*\/.*$author.*\/.*$package.*" | sed 's/\([^\\]\)\./\1[^\\\/]/g')
    if [ -z "$wholeQuery" ]
    then wholeQuery=$query
    else wholeQuery="$wholeQuery\|$query"
    fi
  done
  echo "$wholeQuery"
}

checkQueryAmbiguity() {
  targetPackages=$(getInstalledPackages $*)
  if [ $(count $targetPackages) -ge 2 ]
  then err "query '$*' is ambiguous"
  elif [ $(count $targetPackages) -le 0 ]
  then err "no packages satisfy query '$*'"
  else echo $targetPackages
  fi
}

getInstalledPackages() {
  if [ -d "$osoydir" ]
  then find "$osoydir/packages" -mindepth 3 -maxdepth 3 -type d -regextype sed -regex ".*\($(getQuery $*)\)$"
  fi
}

linkPackagesToBin() {
  output=$(
    for pkg in $(getInstalledPackages $*)
    do
      find "$pkg" -maxdepth 1 -type f,l | while read file
      do [ -x "$file" ] && linkToBin "$file"
      done
    done
  )
  echo "$output" | grep -v '^$'
  msg "$(echo "$output" | grep -vc '^$') symbolic link(s) added"
}

unlinkPackagesFromBin() {
  output=$(
    for pkg in $(getInstalledPackages $*)
    do
      find "$pkg" -maxdepth 1 -type f,l | while read file
      do [ -x "$file" ] && unlinkFromBin "$file"
      done
    done
  )
  echo "$output" | grep -v '^$'
  msg "$(echo "$output" | grep -vc '^$') symbolic link(s) removed"
}

removePackages() {
  pkgsToRemove=$(getInstalledPackages $*)
  if [ $(count $pkgsToRemove) -gt 0 ]
  then
    msg 'Removing following packages:'
    echo "$pkgsToRemove"
    promptYes 'Proceed?' && {
      unlinkPackagesFromBin $*
      for pkg in $(getInstalledPackages $*)
      do msg "Removing $pkg"; rm -rf "$pkg"
      done
    }
  else msg "no packages satisfy query '$*'"
  fi
}

listPackages() {
  for pkg in $(getInstalledPackages $*)
  do
    getPackageId "$pkg"
    find "$pkg" -maxdepth 1 -type f,l | while read file
    do [ -x "$file" ] && {
      symbolic=$(inBin "$file")
      if [ -n "$symbolic" ]
      then printf '  %s <- \033[1m\033[36m%s\033[0m\n' "$(getFilename "$file")" "$symbolic"
      else printf '  \033[2m%s\033[22m\n' "$(getFilename "$file")"
      fi
    } done
  done
}

updatePackages() {
  for pkg in $(getInstalledPackages $*)
  do
    msg "Updating $(getPackageId "$pkg")"
    pullResult=$(cd "$pkg" && git pull)
    echo "$pullResult"
    [ "$pullResult" != 'Already up to date.' ] && {
      unlinkPackagesFromBin "$pkg"
      linkPackagesToBin "$pkg"
    }
  done
}

packageUrl() { echo "$1://$2/$3/$4/"; }
httpStatus() { curl -s -o /dev/null -I -w "%{http_code}" "$*"; }

clonePackages() {
  for i in "$@"
  do
    id=$(echo "$i" | tr '/' ' ')
    package=$(nth -1 $id)
    author=$(nth -2 $id)
    domain=$(nth -3 $id)

    if [ -z "$author" ]
    then
      if [ -n "$a" ]
      then author=$a
      else author=$package
      fi
    fi

    publicSources=
    if [ -n "$domain" ]
    then publicSources=$domain
    elif [ -n "$d" ]
    then publicSources=$d
    else
      msg "Querying $author/$package"
      for domain in github.com gitlab.com bitbucket.org
      do
        link=$(packageUrl $p $domain $author $package)
        status=$(httpStatus $link)
        echo "$status :: $link"
        [ "$status" = 200 ] && publicSources="$publicSources $domain"
      done
    fi

    if [ -z "$publicSources" ]
    then msg "No sources found for $author/$package. Try using flag -d <domain> to enforce a domain"
    else
      sourcesCount=$(count $publicSources)
      answer=0
      if [ $sourcesCount -eq 1 ]
      then answer=1
      else
        msg -n "Available sources:"
        i=0
        for domain in $publicSources
        do
          i=$((i+1))
          printf '  %d) %s' $i $domain
        done
        echo
        while [ $answer -lt 1 ] || [ $answer -gt $sourcesCount ]
        do
          msg -n 'Enter a number (default=1): '
          if [ -n "$y" ]
          then echo; answer=$(printf '\n')
          else read -r answer
          fi
          if [ "$answer" = "$(printf '\n')" ]
          then answer=1
          else answer=$(printf '%d' "$answer")
          fi
        done
      fi
      domain=$(nth $((answer-1)) $publicSources)
      toDir 'packages' $domain $author
      if [ -d $package ]
      then
        msg 'Package with the same author and name has already been installed'
        msg 'Using "osoy update <package>" is recommended'
        { promptNo "Do you want to overwrite $domain/$author/$package?" && removePackages "$domain/$author/$package"; } ||
          continue
      fi
      gitFlags=
      [ -z "$B" ] && gitFlags="$gitFlags --single-branch"
      [ -n "$b" ] && gitFlags="$gitFlags --branch $b"
      git clone $gitFlags "$(packageUrl $p $domain $author $package)" &&
        promptYes "Symlink $package's executables?" &&
          linkPackagesToBin "$domain/$author/$package"
    fi
  done
  msg 'Done'
}

viewPackageFile() {
  targetName=$1; shift
  validFiles=$(find "$*" -type f -iname "$targetName*" | sort)
  if [ $(echo "$validFiles" | grep -vc '^$') -ge 1 ]
  then
    targetFile=$(echo "$validFiles" | head -n 1)
    if command -v less >/dev/null
    then less "$targetFile"
    elif command -v more >/dev/null
    then more "$targetFile"
    elif command -v vim >/dev/null
    then vim -R "$targetFile"
    else err 'less, more or vim are required to view files'
    fi
  else err "no $targetName file was found"
  fi
}



# main() {
  d=
  a=
  p=
  b=
  B=
  y=
  f=
  v=
  h=
  args=
  currentflag=
  for arg in "$@"
  do
    arg=$(echo "$arg" | join)
    if [ -n "$currentflag" ]
    then
      flag=$currentflag
      currentflag=
      case $flag in
        d) d=$arg; continue ;;
        a) a=$arg; continue ;;
        p) p=$arg; continue ;;
        b) b=$arg; continue ;;
        *) err "unknown flag '-$flag'"
      esac
    fi
    if [ "$(echo "$arg" | cut -b 1)" = '-' ]
    then
      flagBundle=$(echo "$arg" | cut -b 2- | sed 's/\(.\)/\1 /g')
      flagBundleCount=$(count $flagBundle)
      i=0
      for flag in $flagBundle
      do i=$((i+1))
        case $flag in
          B) B=1 ;;
          y) y=1 ;;
          f) f=1 ;;
          v) v=1 ;;
          h) h=1 ;;
          *)
            if [ $i -eq $flagBundleCount ]
            then currentflag=$flag
            else err "unknown flag '-$flag'"
            fi
            ;;
        esac
      done
    else args="$args $arg"
    fi
  done
  [ -n "$currentflag" ] && err "flag '-$currentflag' is either unknown or requires a value"
  [ -z "$p" ] && p='https'

  operator=$(nth 0 $args)

  if [ -z $operator ]
  then
    [ -n "$v" ] && [ "$(getFilename "$0")" = 'osoy' ] && {
        cd $(ls -l "$0" | sed -n 's/^.* -> \(.*\)\/[^\/]\+$/\1/p') &&
          git log --pretty=oneline -50 | sed -n 's/^.* v\([0-9]\+\.[0-9]\+\.[0-9]\+\)\( .*\)\?$/\1/p' | head -n 1; }
    [ -n "$h" ] && help
    [ $# -eq 0 ] && {
      B=1
      y=1
      clonePackages github.com/osoy/osoy
    }
  else
    case $operator in
      c|clone)
        [ $(count $args) -lt 2 ] && err 'no packages specified'
        clonePackages $(slice 1 -1 $args)
        ;;
      s|symlink)
        linkPackagesToBin $(slice 1 -1 $args)
        ;;
      r|remove)
        [ $(count $args) -lt 2 ] && err 'no packages specified'
        removePackages $(slice 1 -1 $args)
        ;;
      u|update)
        updatePackages $(slice 1 -1 $args)
        ;;
      l|list)
        listPackages $(slice 1 -1 $args)
        ;;
      dir)
        [ $(count $args) -lt 2 ] && err 'no package specified'
        checkQueryAmbiguity $(slice 1 -1 $args)
        ;;
      read)
        [ $(count $args) -lt 2 ] && err 'no package specified'
        viewPackageFile 'readme' $(checkQueryAmbiguity $(slice 1 -1 $args))
        ;;
      license)
        [ $(count $args) -lt 2 ] && err 'no package specified'
        viewPackageFile 'license' $(checkQueryAmbiguity $(slice 1 -1 $args))
        ;;
      uninstall)
        promptNo "Remove all packages and osoy?" && { rm -rvf "$osoydir" & }
        ;;
      *) err "unknown operator '$operator'" ;;
    esac
  fi
# }
